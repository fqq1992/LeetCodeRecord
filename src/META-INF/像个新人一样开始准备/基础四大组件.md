#### Activity.
   1、manifest走起。基本属性有

   ```
   android:name    必须为完整class路径。
   android:label   标签。不写的话 默认读取application。
   android:configChanges    这个有很多 主要是屏幕旋转、键盘之类的
   android:windowSoftInputMode
   android:launchMode  singleTop/singleInstance/SingleTask/standard 默认情况下启动Act栈的不同情况。
   android:theme    主题
   android:noHistory    是否栈历史。
   android:finishOnTaskLaunch   是否关闭当前Act当 重启launch的时候
   android:process="string"
        运行进程。默认进程与包名一致。四大组件/application都可以覆盖属性。
        如果这个属性被分配的名字以:开头，当这个act运行时,会出现私有子进程。
        如果这个进程名以小写字母开头，这个activity将会运行在全局的进程中。可以通过shareUID 共享给其他APP运行。
   android:multiprocess=“true”
        通过这个属性可以让一个默认进程的act，实例化多份到不同进程。所属进程为前一act的进程。
        当SingleInstance 属性并行时。只打开第一个进程中的Act.保持App所有进程内SingleInstance.
   android:taskAffinity="string"
        act任务栈信息。默认为应用包名。TaskAffinity 属性一般跟singleTask模式或者跟allowTaskReparenting属性结合使用，在其他情况下没有实际意义。
        配合singleTask，可以开启新的任务栈。
   android:allowTaskReparenting="true"
        默认为false。true的时候，会出现 从短信A 打开链接浏览器B 加载页面C.页面c 存在于短信A的栈中。当浏览器B启动时，复制到当前栈空间。

   android:alwaysRetainTaskState
        给了当前Activity所在的任务栈一个“免死金牌”。不会受到任何清理命令的影响
   ```
常见复杂数据基本就这么多了。 结尾基本都是进程间相关，补充一些 多进程特点

    1、分摊主进程内存，独立的内存空间。
    2、即使子进程真被销毁掉了，也不影响主进程发挥。降低崩溃率。
    3、主进程退出，子进程仍然可以工作。

2、接着不得不提一下生命周期。

    主要是7个函数方法。onCreate/onStart/onResume/onPause/onStop/onDestroy/onReStart.
    actA --> actB
    onPause（A）---- onCreate（B） ---- onStart（B）---- onResume（B）--- onStop（A）

    当activity切换的时候，都是先执行栈顶activity的onPause（）方法，然后执行将要到达栈顶的activity的生命周期方法，当新的activity执行完onResume（）方法的时候，再去执行原栈顶activity的生命周期方法.


接着其实可以带一下fragment协作时候的生命周期。

3、AMS中对Activity的栈管理。

    1、AMS中可能管理多个屏幕设备，存放在ActivityDisplays列表中。
    2、每个屏幕在AMS中对应一个ActivityDisplay的数据结构。
    3、一个屏幕中会有多个ActivityStack。
    4、一个ActivityStack中可能会有多个TaskRecord。
    5、一个TaskRecord中可能会有多个ActivityRecord。

        ActivityRecord对应一个Activity，是Activity在AMS服务中的数据结构。
        TaskRecord对应Android中提到的任务栈。
    [详情](https://www.jianshu.com/p/60d075750376)


4、Activity跳转时 AMS的主要流程。


                        activity
    startActivity入口-> :startActivityForResult->Instrumentation.execStartActivity()
    ->ActivityManager.getService().startActivity()->ActivityManagerService.startActivity()
    ->ActivityManagerService.startActivityAsUser()->ActivityStarterController->ActivityStarter.startActivityMayWait(startActivity)
    ->ActivityStarter.startActivityUnchecked()->ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()
    ->ActivityStackSupervisor.scheduleLaunchTaskBehindComplete()->通过IPC APPThread.sendMessage->ActivityThread.handler
    ->AndroidThreadH具体的实现类。


总结一波：

AMS 是核心。在这负责与ActivityStackSupervisor通信。

ActivityStackSupervisor管理任务栈，通过SparseArray<ActivityDisplay>，管理ActivityStack。

ActivityStack是Activity的栈，即任务栈，从中可以获取需要进行操作的ActivityRecord，并且可以对任务的进程进行操作。

ActivityThread是安卓java应用层的入口函数类，它会执行具体对Activity的操作，并将结果通知给ActivityManagerService。


#### Broadcast.

    广播从注册方式分   动态、静态；
    从执行顺序分       有序无序。
    种类分            粘性(21废弃)、LocalBroadcastManager本地广播、普通广播。


#### Service.